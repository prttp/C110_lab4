/*************************************************************
	Практическое занятие №3-курс-С110. Структуры
//динамический массив структур
//поиск
//сортировка
//сохранение в файле
//чтение из файла
*************************************************************/



#define	  stop __asm nop	
#include "book.h"
#include "cards.h"


void main()
{
/*/Тема "Старые" потоковые функции стандартной библиотеки
//Задание 1. С помощью функции scanf сформирйуте три коэффициента: A,B,C
	int A, B, C;
	scanf_s("%d", &A);
	scanf_s("%d", &B);
	scanf_s("%d", &C);
//Задание 2. Выведите (красиво!) таблицу значений y=A*x*x + B*x + C
//при изменении x в диапазоне -2 до +2 с шагом 0.5
	for (double x = -2.0; x <= 2.0; x += 0.5) {
		if (x < 0) {
			if (x / static_cast<int>(x) == 1) {
				std::cout << x << "____________" << A * x * x + B * x + C << std::endl;
			}
			else { std::cout << x << "__________" << A * x * x + B * x + C << std::endl; }
		}
		else if (x > 0) {
			if (x / static_cast<int>(x) == 1) {
				std::cout << x << "_____________" << A * x * x + B * x + C << std::endl;
			}
			else { std::cout << x << "___________" << A * x * x + B * x + C << std::endl; }
		} else { std::cout << x << "_____________" << A * x * x + B * x + C << std::endl; }
		
	}
	stop

	*///Тема. Структуры С.	
//Задание 3.1 Объявите структуру BOOK, описывающую книгу
//(автор, заглавие, год издания, цена, категория…).
//Подумайте: какого типа могут быть поля структуры.
//Подсказка: объявление структуры рекомендуется выносить
//в заголовочный файл.

	//Задание 3.2. Создайте разными способами экземпляры (объекты) типа BOOK 
stop
	//a) глобальный объект типа BOOK создайте без инициализации
	static BOOK b1;
	//б) динамический объект типа BOOK создайте также без инициализации
	BOOK* b2 = new BOOK;
	//в) локальный объект типа BOOK создайте без инициализации, но позднее заполните вручную поля структуры некоторыми значениями
	BOOK b3;
	strcpy_s(b3.author, "Pushkin");
	strcpy_s(b3.name, "Evgeny Onegin");
	b3.year = 2005;
	b3.price = 299.90;
	b3.category = POETRY;
	
	//г) статический объект типа BOOK создайте  и проинициализируйте при определении с помощью списка инициализации.
	static BOOK b4 = { "Marks", "Kapital", 2010, 659.90, SCIENCE };
	stop

		//Используйте структуру BOOK, созданную в предыдущем задании.
		//Для этого достаточно переписать и подключить к проекту файлы book.h и book.cpp

		//Определите - сколько памяти отводит компилятор под каждый такой объект. 
		size_t b = sizeof(b1);
	b = sizeof(b2);
	b = sizeof(b3);
	b = sizeof(b4);
	//Подумайте: от чего зависит объем выделяемой памяти? -от типов переменных в структуре

	
	//Задание 3.3.1 Напишите функцию, выводящую на экран реквизиты книги. 
	//Прототип функции поместите в файл "book.h", а реализацию - в "book.cpp"
	//Подумайте: как эффективнее передавать экземпляр BOOK в функцию.
	//Для вывода на консоль используйте функцию стандартной библиотеки printf

	//Задание 3.3.2
	//С помощью разработанной функции выведите на консоль информацию о книгах, созданных в п.1.2 (кроме динамической)
	PrintBook(b1);
	PrintBook(b3);
	PrintBook(b4);

	//Задание 3.4.1 Напишите функцию для формирования полей структуры.
	//Прототип функции поместите в файл "book.h", а реализацию - в "book.cpp"
	//Для ввода используйте функцию стандартной библиотеки scanf

	//Замечание: неплохо заложить в такую функцию возможность проверки
	//корректности введенного значения, например, год издания не может быть
	//меньше, чем... (год появления письменности), категорию пользователь
	//должен выбирать из существующих, цена не может быть отрицательной...

	//Задание 3.4.2
	//Используйте разработанную функцию для заполнения полей динамически созданного экземпляра книги 
	//распечатайте содержимое этой книги с помощью функции, соданной в п.1.3.1 
	//
	AddBook(b2);
	PrintBook(*b2);
	delete b2;
	b2 = 0;
//----------------------------------------------------------------------------------------------------------------
	//Задание 4. Создаем «картотеку».
	CARD_INDEX cards = { 0 };
	InitCards(1, cards);

	//Пользователь должен иметь возможность по своему желанию выполнять
	//разные действия с картотекой => нужно такую возможность ему
	//предоставить: это может выглядеть как вывод "меню" (перечень
	//возможных действий и соответствующих реакций пользователя), например:
	//Распечатать содержимое картотеки (1)
	//Ввести новую книгу (2)
	//Удалить существующую(ие) (3)
	//Записать текущее содержимое картотеки в файл (4)
	//Считать из файла содержимое в картотеку (5)
	//...
	//Выход из программы (...)
	int cmd = 0;

	do {
		printf("Enter the command: \n Print all the cards(1)\n Add book to the cards(2)\n Delete book from the cards(3)\n Sort the cards by...(4)\n Exit the program(0)\n");
		scanf_s("%i", &cmd);
		switch (cmd) {
		case 1: PrintCards(cards); break;
		case 2: {BOOK book; AddBook(&book); AddBookToCards(book, cards); break; }
		case 3: size_t index; printf("Enter the index of the book, that you want to delete: \n"); scanf_s("%d", &index); DeleteBookFromCards(index, cards); break;
		case 4: {
			int cmd1 = 0;
			printf("Sort by: \n Author(1)\n Title(2)\n Year(3)\n Price(4)\n Genre(5)\n Go back(0)\n");
			scanf_s("%i", &cmd1);
			SortBy(cmd1, cards);
		}
		}
	} while (cmd != 0);
	
	//«Картотека» - это массив структур => нужно такой массив создать.
	//Замечание: размер массива придется увеличиватьпо мере добавления книг => Каким должен быть такой массив???	

	//Помимо самого массива потребуется хранить дополнительно текущие значения количества книг и емкости этого массива,
	//так как эти значения могут изменяться в процессе работы
	//Поскольку эти параметры логически связаны, имеет смысл объединить их в структуру, например, CARD_INDEX
	// ПОДРОБНЫЕ ПОДСКАЗКИ к работе над картотекой описаны в файле  "Картотека_2021.pdf"

	//Реализуйте посредством функций разные возможности работы с картотекой
	
	// Упрощения:
	//1. пусть автор и заглавие книги состоят из одного слова
	//2. все строки можно задавать латинскими буквами. 
	//   для вывода русских символов требуется установить кодировку  -	setlocale(LC_CTYPE, ".1251");
	//   (заголовочный файл <clocale>)
	//   Если хочется не только выводить, но и вводить русские символы, следует
	//   а) пользоваться расширенными функциями ввода/вывода - wprintf(), wscanf()
	//   б) хранить строки как расширенные - wchar_t
	//   в) установить кодировку для ввода русских символов - setlocale(LC_CTYPE, ".866");
	
	

	//Подсказка1: для файлового ввода/вывода используйте функции fprintf и fscanf
	//(заголовочный файл <cstdio>



	// Подсказка2: удобно в качестве первого данного в файле хранить количество
	// книг в картотеке
	//Если файл существует и его удалось открыть
	//if()
	//{
	//Чтение данных из файла
	//а) считали количество элементов
	//б) создали массив требуемой размерности
	//в) считали данные из файла в массив
	//}



	stop
	//****************************************************************
	//Задание 5. Предоставьте пользователю возможность выводить перечень книг
	//в определенном порядке => напишите функцию (функции) сортировки массива
	//по любому из полей структуры.
	// НЕ (!!!) используйте функцию sort  из предыдущей лабораторной работы, а напишите 
	//функцию  сортировки сами  (либо  selection, либо пузырьковую)

	//Замечание: признак - "по какому полю сортируем" можно ввести с помощью
	//перечисления.
	for (int i = 0; i < cards.count; i++) {
		delete cards.pB[i];
	}
	delete[] cards.pB;
	cards.pB = nullptr;
//При завершении программы пребуется очистить динамическую память. Не забудьте это сделать

}